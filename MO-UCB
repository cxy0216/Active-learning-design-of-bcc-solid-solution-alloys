import numpy as np
import pandas as pd
from bayes_opt import BayesianOptimization
import joblib
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings("ignore", category=UserWarning)  # 忽略用户警告
warnings.filterwarnings("ignore", category=DeprecationWarning)  # 忽略弃用警告

def safe_log(x):
    return np.log(x) if x > 0 else 0  # 对于非正值返回0，避免对零取对数
# 定义贝叶斯优化的目标函数
def objective_function(V, Zr, Nb, Hf, Ta, Al, Mo, T1, t1, cold_rolling, T2, t2, models):
    # 使冷轧只有80%和90%两个选择
    if cold_rolling < 85:
        cold_rolling = 80
    else:
        cold_rolling = 90

    # 使再结晶温度只有900℃和1000℃两个选择
    if T2 < 950:
        T2 = 900
    else:
        T2 = 1000

    # 先将其他元素的含量四舍五入到小数点后两位
    V = round(V, 2)
    Zr = round(Zr, 2)
    Nb = round(Nb, 2)
    Hf = round(Hf, 2)
    Ta = round(Ta, 2)
    Al = round(Al, 2)
    Mo = round(Mo, 2)

    # 计算所有其他元素的总和
    other_elements_sum = V + Zr + Nb + Hf + Ta + Al + Mo

    # 设置Ti为1减去其他元素的和，如果其他元素和超过1，则Ti设为0
    Ti = max(0, 1 - other_elements_sum)
    Ti = round(Ti, 2)

    # 如果所有元素的和不等于1，需要重新归一化
    elements = [Ti, V, Zr, Nb, Hf, Ta, Al, Mo]
    total = sum(elements)

    if total > 0 and abs(total - 1) > 1e-10:  # 考虑浮点数精度问题
        elements = [round(e/total, 2) for e in elements]
        Ti, V, Zr, Nb, Hf, Ta, Al, Mo = elements

    # 示例约束
    while not (0.0 <= Ti <= 0.67 and 0 <= V <= 0.2 and 0 <= Zr <= 0.04 and
               0.1 <= Nb <= 0.3 and 0.05 <= Hf <= 0.15 and Ta == 0 and
               0.05 <= Al <= 0.2 and Mo == 0):

        # 调整V
        if V < 0: V = 0
        elif V > 0.2: V = 0.2

        # 调整Zr
        if Zr < 0: Zr = 0
        elif Zr > 0.3: Zr = 0.3

        # 调整Nb
        if Nb < 0.1: Nb = 0.1
        elif Nb > 0.3: Nb = 0.3

        # 调整Hf
        if Hf < 0.05: Hf = 0.05
        elif Hf > 0.15: Hf = 0.15

        Ta = 0

        # 调整Al
        if Al < 0.05: Al = 0.05
        elif Al > 0.2: Al = 0.2

        Mo = 0

        # 先四舍五入其他元素
        V = round(V, 2)
        Zr = round(Zr, 2)
        Nb = round(Nb, 2)
        Hf = round(Hf, 2)
        Ta = round(Ta, 2)
        Al = round(Al, 2)
        Mo = round(Mo, 2)

        # 重新计算Ti为1减去其他元素
        other_elements_sum = V + Zr + Nb + Hf + Ta + Al + Mo
        Ti = max(0, 1 - other_elements_sum)
        Ti = round(Ti, 2)

        # 检查Ti是否在允许范围内
        if Ti > 0.67:
            # 如果Ti超出范围，按比例增加其他可调整元素
            excess = Ti - 0.67
            Ti = 0.67

            # 分配超出部分到其他元素
            adjustable_elements = [V, Zr, Nb, Hf, Al]  # Ta和Mo为0，不调整
            max_limits = [0.2, 0.3, 0.3, 0.15, 0.2]
            current_sum = sum(adjustable_elements)

            if current_sum > 0:
                for i in range(len(adjustable_elements)):
                    # 按比例分配excess
                    adj = min(excess * adjustable_elements[i] / current_sum, max_limits[i] - adjustable_elements[i])
                    adjustable_elements[i] += adj

                V, Zr, Nb, Hf, Al = adjustable_elements
            else:
                # 如果所有可调整元素都为0，则平均分配
                for i in range(len(adjustable_elements)):
                    adjustable_elements[i] += excess / len(adjustable_elements)
                    if adjustable_elements[i] > max_limits[i]:
                        adjustable_elements[i] = max_limits[i]

                V, Zr, Nb, Hf, Al = adjustable_elements

        # 先对其他元素四舍五入
        V = round(V, 2)
        Zr = round(Zr, 2)
        Nb = round(Nb, 2)
        Hf = round(Hf, 2)
        Ta = round(Ta, 2)
        Al = round(Al, 2)
        Mo = round(Mo, 2)

        # 计算Ti值
        other_elements_sum = V + Zr + Nb + Hf + Ta + Al + Mo
        Ti = max(0, 1 - other_elements_sum)
        Ti = round(Ti, 2)

        # 如果各元素总和不为1，需要调整
        total = Ti + other_elements_sum
        if total > 0 and abs(total - 1) > 1e-10:
            # 如果总和不为1但接近1，优先调整Ti
            if abs(total - 1) <= 0.02 and Ti >= 0.02:
                Ti = round(Ti - (total - 1), 2)
            else:
                # 否则才进行完整的归一化
                elements = [Ti, V, Zr, Nb, Hf, Ta, Al, Mo]
                elements = [round(e/total, 2) for e in elements]
                Ti, V, Zr, Nb, Hf, Ta, Al, Mo = elements

    # 输出生成的成分值
    print(f"Generated composition: Ti={Ti:.2f}, V={V:.2f}, Zr={Zr:.2f}, Nb={Nb:.2f}, "
          f"Hf={Hf:.2f}, Ta={Ta:.2f}, Al={Al:.2f}, Mo={Mo:.2f}")

    # # 工艺参数约束
    # # T1范围检查：均匀化温度
    # if T1 < 800: T1 = 800
    # elif T1 > 1200: T1 = 1200

    # # t1范围检查：均匀化时间(小时)
    # if t1 < 1: t1 = 1
    # elif t1 > 24: t1 = 24

    # # cold_rolling范围检查：冷轧率
    # if cold_rolling < 50: cold_rolling = 50
    # elif cold_rolling > 90: cold_rolling = 90

    # # T2范围检查：再结晶温度
    # if T2 < 700: T2 = 700
    # elif T2 > 1100: T2 = 1100

    # # t2范围检查：再结晶时间(分钟)
    # if t2 < 5: t2 = 5
    # elif t2 > 120: t2 = 120

    # print(f"Process parameters: T1={T1:.1f}°C, t1={t1:.1f}h, cold_rolling={cold_rolling:.1f}%, "
    #       f"T2={T2:.1f}°C, t2={t2:.1f}min")

    # ===================== X1特征计算 (屈服强度) =====================
    # X1_14 = Ti*0.079 + V*0.525 + Zr*0.426 + Nb*0.917406 + Hf*0.014 + Ta*0.322 + Al*0.43283 + Mo*0.748
    X1_14 = Ti*0.079 + V*0.525 + Zr*0.426 + Nb*0.917406 + Hf*0.014 + Ta*0.322 + Al*0.43283 + Mo*0.748

    # X1_15 = Ti*1.54 + V*1.63 + Zr*1.33 + Nb*1.6 + Hf*1.3 + Ta*1.5 + Al*1.61 + Mo*2.16
    X1_15 = Ti*1.54 + V*1.63 + Zr*1.33 + Nb*1.6 + Hf*1.3 + Ta*1.5 + Al*1.61 + Mo*2.16

    # X1_16 = Ti*2.95 + V*3.02 + Zr*3.23 + Nb*3.3 + Hf*3.2 + Ta*3.31 + Al*4.05 + Mo*3.15
    X1_16 = Ti*2.95 + V*3.02 + Zr*3.23 + Nb*3.3 + Hf*3.2 + Ta*3.31 + Al*4.05 + Mo*3.15

    # X1_17 计算原子半径差异
    sum_atomic_weight = Ti*146.2 + V*131.6 + Zr*160.3 + Nb*142.9 + Hf*157.8 + Ta*146 + Al*143.2 + Mo*139
    X1_17 = 100 * np.sqrt(
        Ti * (1 - 146.2/sum_atomic_weight)**2 +
        V * (1 - 131.6/sum_atomic_weight)**2 +
        Zr * (1 - 160.3/sum_atomic_weight)**2 +
        Nb * (1 - 142.9/sum_atomic_weight)**2 +
        Hf * (1 - 157.8/sum_atomic_weight)**2 +
        Ta * (1 - 146/sum_atomic_weight)**2 +
        Al * (1 - 143.2/sum_atomic_weight)**2 +
        Mo * (1 - 139/sum_atomic_weight)**2
    )

    # X1_18 分数式
    # 计算总和部分 - 不进行任何简写或合并
    sum_part = (Ti*146.2 + V*131.6 + Zr*160.3 + Nb*142.9 + Hf*157.8 + Ta*146 + Al*143.2 + Mo*139)

    # 计算分子的第一部分 - 完全按照Excel公式结构
    numerator_part1_power1 = (sum_part + 131.6)**2
    numerator_part1_power2 = sum_part**2
    numerator_part1_subtraction = numerator_part1_power1 - numerator_part1_power2
    numerator_part1_denominator = (sum_part + 131.6)**2
    numerator_part1_division = numerator_part1_subtraction / numerator_part1_denominator
    numerator_part1_sqrt = np.sqrt(numerator_part1_division)
    numerator_final = 1 - numerator_part1_sqrt

    # 计算分母的第一部分 - 完全按照Excel公式结构
    denominator_part1_power1 = (sum_part + 160.3)**2
    denominator_part1_power2 = sum_part**2
    denominator_part1_subtraction = denominator_part1_power1 - denominator_part1_power2
    denominator_part1_denominator = (sum_part + 160.3)**2
    denominator_part1_division = denominator_part1_subtraction / denominator_part1_denominator
    denominator_part1_sqrt = np.sqrt(denominator_part1_division)
    denominator_final = 1 - denominator_part1_sqrt

    # 最终计算X1_18 - 分子除以分母
    X1_18 = numerator_final / denominator_final

    # X1_19 原子半径差异与其他参数乘积
    modulus_sum = Ti*116 + V*128 + Zr*68 + Nb*105 + Hf*78 + Ta*186 + Al*70 + Mo*230
    X1_19 = 0.5 * modulus_sum * X1_17

    # X1_20 综合参数
    elastic_modulus = Ti*44 + V*47 + Zr*33 + Nb*38 + Hf*30 + Ta*69 + Al*26 + Mo*120
    X1_20 = 2 * elastic_modulus / (1 - X1_19)

    # X1_21 二元相互作用能
    X1_21 = (
        14.6*Ti*V*2 + 14.1*Ti*Zr + 3.3*Ti*Nb + 11.6*Ti*Hf + 0.2*Ti*Ta + 3*Ti*Al +
        28.7*V*Zr + 11.3*V*Nb + 26.2*V*Hf + 14.4*V*Ta + 11.6*V*Al +
        17.4*Zr*Nb + 2.5*Zr*Hf + 14.3*Zr*Ta + 17.1*Zr*Al +
        14.9*Nb*Hf + 3.1*Nb*Ta + 0.3*Nb*Al +
        11.8*Hf*Ta + 14.6*Hf*Al + 2.8*Ta*Al +
        Mo*Ti*7.2 + Mo*V*7.4 + Mo*Zr*21.3 + Mo*Nb*3.9 + Mo*Hf*18.8 + Mo*Ta*7 + Mo*Al*4.1
    )

    # X1_22 复合参数
    X1_22 = (elastic_modulus * X1_17 * (1 + X1_19)) / (1 - X1_19)

    # ===================== X2特征计算 (延伸率) =====================
    # X2_14 原子质量
    X2_14 = Ti*47.867 + V*50.9415 + Zr*91.224 + Nb*92.90637 + Hf*178.49 + Ta*180.94788 + Al*26.9815385 + Mo*95.95

    # X2_15 密度
    X2_15 = Ti*4.506 + V*6 + Zr*6.52 + Nb*8.57 + Hf*13.3 + Ta*16.4 + Al*2.7 + Mo*4.2

    # X2_16 相同于X1_14
    X2_16 = Ti*0.079 + V*0.525 + Zr*0.426 + Nb*0.917406 + Hf*0.014 + Ta*0.322 + Al*0.43283 + Mo*0.748

    # X2_17 价电子数
    X2_17 = Ti*4 + V*5 + Zr*4 + Nb*5 + Hf*4 + Ta*5 + Al*3 + Mo*6

    # X2_18 电负性
    X2_18 = Ti*1.54 + V*1.63 + Zr*1.33 + Nb*1.6 + Hf*1.3 + Ta*1.5 + Al*1.61 + Mo*2.16

    # X2_19 熔点
    X2_19 = Ti*2.95 + V*3.02 + Zr*3.23 + Nb*3.3 + Hf*3.2 + Ta*3.31 + Al*4.05 + Mo*3.15

    # X2_20 硬度
    X2_20 = Ti*970 + V*628 + Zr*903 + Nb*1320 + Hf*1760 + Ta*873 + Al*167 + Mo*1530

    # X2_21 晶格常数
    X2_21 = Ti*4.33 + V*4.3 + Zr*4.05 + Nb*4.3 + Hf*3.9 + Ta*4.25 + Al*4.28 + Mo*4.37

    # X2_22 电负性差异
    avg_electronegativity = Ti*1.54 + V*1.63 + Zr*1.33 + Nb*1.6 + Hf*1.3 + Ta*1.5 + Al*1.61 + Mo*2.16
    X2_22 = 100 * np.sqrt(
        Ti * (1.54 - avg_electronegativity)**2 +
        V * (1.63 - avg_electronegativity)**2 +
        Zr * (1.33 - avg_electronegativity)**2 +
        Nb * (1.6 - avg_electronegativity)**2 +
        Hf * (1.3 - avg_electronegativity)**2 +
        Ta * (1.5 - avg_electronegativity)**2 +
        Al * (1.61 - avg_electronegativity)**2 +
        Mo * (2.16 - avg_electronegativity)**2
    )

    # 构建特征向量
    # X1用于屈服强度预测
    # 定义列名
    # 定义列名 - 使用正确的中文括号
    X1_columns = [
        'Ti', 'V', 'Zr', 'Nb', 'Hf', 'Ta', 'Al', 'Mo',  # 8个元素成分
        '均匀化T1', 't1（h）', '冷轧%', '再结晶T2', 't2（min）',  # 5个工艺参数 - 注意这里使用了中文括号
        'EA', 'χ', 'a', 'δr', 'γ', 'μ', 'F', 'D.r', 'A'  # 9个计算特征
    ]

    X2_columns = [
        'Ti', 'V', 'Zr', 'Nb', 'Hf', 'Ta', 'Al', 'Mo',  # 8个元素成分
        '均匀化T1', 't1（h）', '冷轧%', '再结晶T2', 't2（min）',  # 5个工艺参数 - 注意这里使用了中文括号
        'Ar', 'ρ', 'EA', 'VEC', 'χ', 'a', 'Hv', 'w', '△χ'  # 9个计算特征
    ]

    # 构建特征向量
    X1_features = [
        Ti, V, Zr, Nb, Hf, Ta, Al, Mo,      # 8个元素成分
        T1, t1, cold_rolling, T2, t2,       # 5个工艺参数
        X1_14, X1_15, X1_16, X1_17, X1_18, X1_19, X1_20, X1_21, X1_22  # 9个计算特征
    ]

    X2_features = [
        Ti, V, Zr, Nb, Hf, Ta, Al, Mo,      # 8个元素成分
        T1, t1, cold_rolling, T2, t2,       # 5个工艺参数
        X2_14, X2_15, X2_16, X2_17, X2_18, X2_19, X2_20, X2_21, X2_22  # 9个计算特征
    ]

    # 将特征向量转换为DataFrame
    X1 = pd.DataFrame([X1_features], columns=X1_columns)
    X1 = X1.to_numpy()
    X2 = pd.DataFrame([X2_features], columns=X2_columns)
    X2 = X2.to_numpy()

    # 打印查看结果
    print('X1:',X1)
    print('X2:',X2)

    yield_seeds = [39, 40, 41, 42, 43]  # 屈服强度使用的随机种子
    elongation_seeds = [2, 39, 44, 45, 256]  # 延伸率使用的随机种子
    models = load_models(yield_seeds, elongation_seeds)
    # 调用模型预测
    yield_mean_prediction, yield_uncertainty, elongation_mean_prediction, elongation_uncertainty = predict_with_loaded_models(X1, X2, models)


    # 目标函数：最大化屈服强度均值和延伸率，并考虑不确定性
    # 权重可以调整
#     objective_value = (
#     0.25 * (yield_mean_prediction - 304.59454) / 1005.7475
#     + 0.25 * (yield_uncertainty - 11.33473) / 166.66967
#     + 0.25 * (elongation_mean_prediction - 2.10589) / 27.52909
#     + 0.25 * (elongation_uncertainty - 0.58343)/ 3.79867
# )
    objective_value = (yield_mean_prediction + yield_uncertainty) * (elongation_mean_prediction + elongation_uncertainty)
    # 将归一化值转换为实际值 (假设这是模型的比例系数，需要根据实际情况调整)

    # 打印结果
    print(f"Yield Strength: {yield_mean_prediction[0]:.1f} MPa ± {yield_uncertainty[0]}")
    print(f"Elongation: {elongation_mean_prediction[0]:.1f}% ± {elongation_uncertainty[0]}")
    print(f"Objective value: {objective_value[0]:.4f}")

    return float(objective_value)

# 定义贝叶斯优化的参数空间
pbounds = {
    'V': (0, 0.2),     # V含量范围
    'Zr': (0, 0.04),    # Zr含量范围
    'Nb': (0, 0.25),  # Nb含量范围
    'Hf': (0.1, 0.25), # Hf含量范围
    'Ta': (0, 0.000000000001),   # 无Ta
    'Al': (0, 0.1),  # Al含量范围
    'Mo': (0, 0.000000000001),   # 无Mo
    'T1': (25, 25.00000000001),    # 无均匀化
    't1': (0, 0.00000000000001),   # 无均匀化
    'cold_rolling': (80, 90),    # 冷轧：只有80%和90%两个选择
    'T2': (900, 1000),          # 再结晶温度：只有900℃和1000℃两个选择
    't2': (5, 5.000000000000001)  # 再结晶时间：5分钟
}

# pbounds = {
#     'Ti': (0.2500000, 0.25000001),     # Ti含量范围
#     'V': (0.000000001, 0.0000001),     # V含量范围
#     'Zr': (0.2500000, 0.25000001),    # Zr含量范围
#     'Nb': (0.2500000, 0.25000001),     # Nb含量范围
#     'Hf': (0.2500000, 0.25000001),   # Hf含量范围
#     'Ta': (0.000000001, 0.0000001),   # Ta含量范围
#     'Al': (0.000000001, 0.0000001),    # Al含量范围
#     'Mo': (0.000000001, 0.0000001),    # Mo含量范围
#     'T1': (25.00000, 25.000001),    # 均匀化温度：800-1200℃
#     't1': (0, 0.0000001),        # 均匀化时间：1-24小时
#     'cold_rolling': (77.8, 77.80000009),  # 冷轧：50%-90%
#     'T2': (800, 800.00000001),    # 再结晶温度：700-1100℃
#     't2': (60, 60.00000001)        # 再结晶时间：5-120分钟
# }

# 创建贝叶斯优化对象
optimizer = BayesianOptimization(
    f=lambda V, Zr, Nb, Hf, Ta, Al, Mo, T1, t1, cold_rolling, T2, t2: objective_function(
        V, Zr, Nb, Hf, Ta, Al, Mo, T1, t1, cold_rolling, T2, t2, models
    ),
    pbounds=pbounds,
    random_state=42
)

# 进行贝叶斯优化
optimizer.maximize(init_points=5, n_iter=50)

# 输出最优结果时，需要先四舍五入其他元素，再计算Ti的值
best_params = optimizer.max['params']
# 先将其他元素四舍五入到两位小数
rounded_params = {}
for param, value in best_params.items():
    if param in ['V', 'Zr', 'Nb', 'Hf', 'Ta', 'Al', 'Mo']:
        rounded_params[param] = round(value, 2)
    else:
        rounded_params[param] = value

# 计算其他元素的总和
other_elements_sum = (
    rounded_params['V'] + rounded_params['Zr'] + rounded_params['Nb'] +
    rounded_params['Hf'] + rounded_params['Ta'] + rounded_params['Al'] + rounded_params['Mo']
)
Ti_value = round(max(0, 1 - other_elements_sum), 2)

print("Best Parameters:")
print(f"Ti: {Ti_value:.2f}")  # 添加Ti的计算值
for param, value in rounded_params.items():
    if param in ['V', 'Zr', 'Nb', 'Hf', 'Ta', 'Al', 'Mo']:
        print(f"{param}: {value:.2f}")
    else:
        print(f"{param}: {value}")

print("\n详细分析最佳参数组合:")
objective_function(
    rounded_params['V'], rounded_params['Zr'], rounded_params['Nb'],
    rounded_params['Hf'], rounded_params['Ta'], rounded_params['Al'], rounded_params['Mo'],
    rounded_params['T1'], rounded_params['t1'], rounded_params['cold_rolling'],
    rounded_params['T2'], rounded_params['t2'], models
)

# 保存最优结果
best_result = {
    'composition': {
        'Ti': Ti_value,  # 添加计算得到的Ti值
        'V': rounded_params['V'],
        'Zr': rounded_params['Zr'],
        'Nb': rounded_params['Nb'],
        'Hf': rounded_params['Hf'],
        'Ta': rounded_params['Ta'],
        'Al': rounded_params['Al'],
        'Mo': rounded_params['Mo']
    },
    'process': {
        'T1': rounded_params['T1'],
        't1': rounded_params['t1'],
        'cold_rolling': rounded_params['cold_rolling'],
        'T2': rounded_params['T2'],
        't2': rounded_params['t2']
    },
    'objective_value': optimizer.max['target']
}

# 将结果保存到CSV文件
import csv
with open('/content/drive/MyDrive/高熵合金数据/bayesian_optimization_best_result.csv', 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Parameter', 'Value'])
    for category, params in best_result.items():
        if isinstance(params, dict):
            for param_name, param_value in params.items():
                writer.writerow([f"{category}_{param_name}", param_value])
        else:
            writer.writerow([category, params])

print("最佳结果已保存到文件")
